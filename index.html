<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>구몬 학습 - 프리미엄 액티비티</title>
    <!-- Google Fonts: Inter and Noto Sans KR -->
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap"
        rel="stylesheet">
    <!-- Fabric.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        :root {
            --primary: #4F46E5;
            --primary-light: #EEF2FF;
            --secondary: #64748B;
            --bg-main: #F1F5F9;
            --bg-card: #FFFFFF;
            --text-main: #1E293B;
            --text-muted: #64748B;
            --border: #E2E8F0;
            --radius-xl: 24px;
            --radius-lg: 16px;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --accent-blue: #3B82F6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }

        body {
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
            background-color: var(--bg-main);
            color: var(--text-main);
            height: 100vh;
            width: 100vw;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            user-select: none;
        }

        #activity-container {
            position: relative;
            width: 1280px;
            height: 1024px;
            background: var(--bg-card);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-xl);
            overflow: hidden;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }

        /* Nav Header */
        #nav-header {
            position: absolute;
            top: 40px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 32px;
            z-index: 100;
            pointer-events: none;
        }

        #nav-header>* {
            pointer-events: auto;
        }

        #stage-indicator {
            font-size: 14px;
            font-weight: 700;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 0.15em;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(8px);
            padding: 10px 24px;
            border-radius: 100px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-sm);
        }

        .nav-btn {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(8px);
            border: 1px solid var(--border);
            border-radius: 50%;
            width: 48px;
            height: 48px;
            color: var(--text-main);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: var(--shadow-sm);
        }

        .nav-btn:hover:not(:disabled) {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .nav-btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: default;
        }

        /* Canvas Wrapper */
        #canvas-wrapper {
            position: relative;
            flex: 1;
            width: 100%;
            height: 100%;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
        }

        /* Control Boxes */
        .ui-panel {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            padding: 16px 20px;
            border-radius: var(--radius-lg);
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 100;
            box-shadow: var(--shadow-lg);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .ui-panel.hidden {
            display: none;
            opacity: 0;
            transform: translateY(20px);
        }

        #bottom-left-controls {
            bottom: 40px;
            left: 40px;
            display: flex;
            flex-direction: row;
            gap: 12px;
            align-items: flex-end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-label {
            font-size: 11px;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 12px;
            background: var(--bg-main);
            padding: 8px 12px;
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .control-value {
            font-size: 13px;
            font-weight: 700;
            color: var(--primary);
            min-width: 32px;
            text-align: right;
        }

        /* Range Input */
        input[type=range] {
            -webkit-appearance: none;
            width: 120px;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 0 4px white, 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.1s ease;
        }

        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background: transparent;
            border: none;
            font-size: 13px;
            font-weight: 700;
            color: var(--primary);
            cursor: pointer;
            outline: none;
            padding-right: 8px;
        }

        /* Action Buttons */
        #action-container {
            position: absolute;
            bottom: 40px;
            right: 40px;
            display: flex;
            gap: 12px;
            z-index: 100;
        }

        .btn-action {
            height: 56px;
            padding: 0 32px;
            border-radius: 16px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
        }

        .btn-action.primary {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 14px 0 rgba(79, 70, 229, 0.3);
        }

        .btn-action.primary:hover {
            background: #4338CA;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px 0 rgba(79, 70, 229, 0.4);
        }

        .btn-action.secondary {
            background: white;
            color: var(--text-main);
            border: 1px solid var(--border);
            box-shadow: var(--shadow-sm);
        }

        .btn-action.secondary:hover {
            background: var(--bg-main);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .btn-action:active {
            transform: translateY(0);
        }

        /* Tooltip-like values */
        .val-badge {
            background: var(--primary-light);
            color: var(--primary);
            padding: 2px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 800;
        }
    </style>
</head>

<body>

    <div id="activity-container">
        <!-- Navigation -->
        <div id="nav-header">
            <button id="btn-prev" class="nav-btn" title="이전">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"
                    stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="15 18 9 12 15 6"></polyline>
                </svg>
            </button>
            <span id="stage-indicator">STAGE 1</span>
            <button id="btn-next" class="nav-btn" title="다음">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"
                    stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
            </button>
        </div>

        <!-- Canvas -->
        <div id="canvas-wrapper">
            <canvas id="c"></canvas>
        </div>

        <!-- Dynamic Controls -->
        <div id="bottom-left-controls">
            <!-- Scale Control (Direct Input) -->
            <div id="scale-control" class="ui-panel hidden">
                <div class="control-group">
                    <label class="control-label">입력 감도</label>
                    <div class="control-row">
                        <select id="zone-scale">
                            <option value="1.2" selected>120%</option>
                            <option value="1.3">130%</option>
                            <option value="1.4">140%</option>
                            <option value="1.5">150%</option>
                        </select>
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="3" stroke-linecap="round" stroke-linejoin="round"
                            style="color: var(--primary)">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    </div>
                </div>
            </div>

            <!-- Drag & Drop Controls -->
            <div id="drag-controls" class="ui-panel hidden">
                <div style="display: flex; gap: 20px;">
                    <div class="control-group">
                        <label class="control-label">병음 크기</label>
                        <div class="control-row">
                            <input type="range" id="pinyin-slider" min="20" max="60" value="32">
                            <span id="pinyin-val" class="control-value">32</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label class="control-label">한자 크기</label>
                        <div class="control-row">
                            <input type="range" id="hanja-slider" min="60" max="150" value="100">
                            <span id="hanja-val" class="control-value">100</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label class="control-label">화면 배율</label>
                        <div class="control-row">
                            <input type="range" id="screen-slider" min="0.3" max="1.0" step="0.05" value="1.0">
                            <span id="screen-val" class="control-value">100</span>
                            <span style="font-size: 11px; margin-left: -8px; color: var(--text-muted)">%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div id="action-container">
            <button id="reset-btn" class="btn-action secondary">초기화</button>
            <button id="done-btn" class="btn-action primary">입력 완료</button>
        </div>
    </div>

    <script>
        /**
         * CONFIGURATIONS
         * Kept the original structure as requested.
         */
        const CONFIG = {
            CANVAS_WIDTH: 1280,
            CANVAS_HEIGHT: 1024,
            IDLE_TIMEOUT: 2000,
            ANIMATION_DURATION: 800,
            CLUSTER_GAP_THRESHOLD: 45,
            HINT_DURATION: 1800,
            COLORS: {
                text: '#1E293B',
                secondary: '#64748B',
                border: '#E2E8F0',
                targetFill: 'rgba(79, 70, 229, 0.02)',
                targetStroke: '#E2E8F0',
                hint: '#94A3B8',
                activeZone: 'rgba(79, 70, 229, 0.05)',
                activeStroke: '#4F46E5',
                mercuryBlue: '#EEF2FF', // Softened for cleaner look
                accent: '#4F46E5'
            },
            FONTS: {
                main: 'Inter, "Noto Sans KR", sans-serif',
                chinese: '"Noto Sans SC", "Noto Sans KR", serif'
            }
        };

        const STAGES = [
            { id: 1, type: 'normal', inputType: 'pad', title: "Level 1", sentence: { pre: "나는", post: "에 갑니다.", y: 400 }, targets: [{ x: 440, y: 340, width: 220, height: 120 }] },
            { id: 2, type: 'normal', inputType: 'pad', title: "Level 2", sentence: { pre: "나는", post: "에 갑니다.", y: 400 }, targets: [{ x: 440, y: 340, width: 140, height: 120 }, { x: 600, y: 340, width: 140, height: 120 }] },
            { id: 3, type: 'hint_audio', inputType: 'direct', title: "Level 3", sentence: { pre: "나는", post: "에 갑니다.", y: 400 }, targets: [{ x: 440, y: 340, width: 140, height: 120 }, { x: 600, y: 340, width: 140, height: 120 }], hintText: ["학", "교"], audioWord: "학교", maxAudioPlays: 2 },
            { id: 4, type: 'hint_audio', inputType: 'direct', title: "Level 4", sentence: { pre: "나는", post: "에 갑니다.", y: 400 }, targets: [{ x: 440, y: 340, width: 140, height: 120 }, { x: 600, y: 340, width: 140, height: 120 }], hintText: ["학", "교"], audioWord: "학교", maxAudioPlays: 2 },
            {
                id: 10, type: 'drag_drop', inputType: 'drag', title: "Level 6",
                subText: "당신은 밥을 먹었습니까?",
                tokens: [
                    { char: "你", pinyin: "Nǐ", fixed: true },
                    { char: "吃", pinyin: "chī", fixed: false },
                    { char: "饭", pinyin: "fàn", fixed: true },
                    { char: "了", pinyin: "le", fixed: false },
                    { char: "吗", pinyin: "ma", fixed: false }
                ],
                sourceItems: ["ma", "chī", "le"]
            }
        ];

        const WRITING_PAD_CONFIG = { x: 240, y: 640, width: 800, height: 280 };

        // State Variables
        let currentStageIndex = 0;
        let currentStrokes = [];
        let idleTimer = null;
        let isMoving = false;
        let filledSlots = [];
        let activeSlotIndex = 0;
        let audioPlayCount = 0;
        let hintTimer = null;
        let activeZoneRect = null;
        let currentExpansionFactor = 1.2;
        let currentPinyinSize = 32;
        let currentHanjaSize = 100;
        let currentContentScale = 1.0;
        let dropTargets = [];

        // Initialize Canvas
        const canvas = new fabric.Canvas('c', {
            width: CONFIG.CANVAS_WIDTH, height: CONFIG.CANVAS_HEIGHT,
            selection: false, isDrawingMode: true, retinaScaling: true,
            preserveObjectStacking: true
        });

        const brush = new fabric.PencilBrush(canvas);
        brush.color = CONFIG.COLORS.text;
        brush.width = 7;
        canvas.freeDrawingBrush = brush;

        // UI References
        const ui = {
            prev: document.getElementById('btn-prev'),
            next: document.getElementById('btn-next'),
            indicator: document.getElementById('stage-indicator'),
            done: document.getElementById('done-btn'),
            reset: document.getElementById('reset-btn'),
            scalePanel: document.getElementById('scale-control'),
            scaleSelect: document.getElementById('zone-scale'),
            dragPanel: document.getElementById('drag-controls'),
            pinyinSlider: document.getElementById('pinyin-slider'),
            pinyinVal: document.getElementById('pinyin-val'),
            hanjaSlider: document.getElementById('hanja-slider'),
            hanjaVal: document.getElementById('hanja-val'),
            screenSlider: document.getElementById('screen-slider'),
            screenVal: document.getElementById('screen-val')
        };

        /**
         * STAGE LOADING LOGIC
         */
        function loadStage(index) {
            if (index < 0 || index >= STAGES.length) index = 0;

            // Force stop any ongoing drawing before resetting
            canvas.isDrawingMode = false;
            clearTimeout(idleTimer);

            currentStageIndex = index;
            const stage = STAGES[index];

            filledSlots = [];
            activeSlotIndex = 0;
            dropTargets = [];
            audioPlayCount = 0;
            currentStrokes = []; // Explicitly clear before rendering

            ui.indicator.textContent = stage.title;
            ui.prev.disabled = index === 0;
            ui.next.disabled = index === STAGES.length - 1;

            // Show/Hide Panels based on Input Type
            ui.scalePanel.classList.toggle('hidden', stage.inputType !== 'direct');
            const isDrag = stage.inputType === 'drag';
            ui.dragPanel.classList.toggle('hidden', !isDrag);

            if (isDrag) {
                canvas.isDrawingMode = false;
                renderDragStage(stage);
            } else {
                // Ensure drawing mode is ON for handwriting stages to fix "first touch" issue
                canvas.isDrawingMode = true;
                canvas.freeDrawingBrush.color = CONFIG.COLORS.text; // Reset color
                filledSlots = new Array(stage.targets ? stage.targets.length : 0).fill(false);
                renderStage();
                if (stage.hintText) showHints(stage);
                if (stage.inputType === 'direct') updateActiveZoneVisual();
            }
        }

        /**
         * RENDERING LOGIC (Writing Stages)
         */
        function renderStage() {
            canvas.clear();
            canvas.backgroundColor = '#FFFFFF';
            currentStrokes = [];
            isMoving = false;
            activeZoneRect = null;
            const stage = STAGES[currentStageIndex];
            if (!stage.targets) return;
            const targetY = stage.targets[0].y;
            const centerY = targetY + stage.targets[0].height / 2;
            const vOffset = 6;

            // Writing Pad for 'pad' mode
            if (stage.inputType === 'pad') {
                canvas.add(new fabric.Rect({
                    left: WRITING_PAD_CONFIG.x, top: WRITING_PAD_CONFIG.y,
                    width: WRITING_PAD_CONFIG.width, height: WRITING_PAD_CONFIG.height,
                    fill: '#F8FAFC', stroke: CONFIG.COLORS.border, strokeWidth: 1.5,
                    rx: 20, ry: 20, selectable: false, evented: false
                }));
                // Label for Pad
                canvas.add(new fabric.Text("여기에 써보세요", {
                    left: WRITING_PAD_CONFIG.x + 24, top: WRITING_PAD_CONFIG.y + 24,
                    fontSize: 14, fontFamily: CONFIG.FONTS.main, fontWeight: 600,
                    fill: CONFIG.COLORS.secondary, selectable: false, evented: false
                }));
            }

            // Target Slots
            stage.targets.forEach(t => {
                canvas.add(new fabric.Rect({
                    left: t.x, top: t.y, width: t.width, height: t.height,
                    fill: CONFIG.COLORS.targetFill, stroke: CONFIG.COLORS.targetStroke,
                    strokeWidth: 2, rx: 16, ry: 16, selectable: false, evented: false
                }));
            });

            // Sentence Text with improved typography
            const fontSize = 56;
            canvas.add(new fabric.Text(stage.sentence.pre, {
                left: stage.targets[0].x - 40, top: centerY + vOffset,
                fontSize: fontSize, fontFamily: CONFIG.FONTS.main, fontWeight: 700,
                fill: CONFIG.COLORS.text, originX: 'right', originY: 'center', selectable: false
            }));
            const lastT = stage.targets[stage.targets.length - 1];
            canvas.add(new fabric.Text(stage.sentence.post, {
                left: lastT.x + lastT.width + 40, top: centerY + vOffset,
                fontSize: fontSize, fontFamily: CONFIG.FONTS.main, fontWeight: 700,
                fill: CONFIG.COLORS.text, originX: 'left', originY: 'center', selectable: false
            }));

            // If hint_audio, add a speaker icon/button visual
            if (stage.type === 'hint_audio') {
                renderSpeakerButton(stage);
            }

            canvas.renderAll();
        }

        function renderSpeakerButton(stage) {
            const group = new fabric.Group([
                new fabric.Circle({ radius: 24, fill: CONFIG.COLORS.mercuryBlue }),
                new fabric.Path("M11 5L6 9H2V15H6L11 19V5Z M15.54 8.46C16.47 9.39 17 10.63 17 12C17 13.37 16.47 14.61 15.54 15.54", {
                    left: 0, top: 0, originX: 'center', originY: 'center', stroke: CONFIG.COLORS.accent, strokeWidth: 2, fill: 'transparent'
                })
            ], {
                left: 60, top: 200, originX: 'center', originY: 'center', selectable: false, hoverCursor: 'pointer'
            });

            group.on('mousedown', () => {
                if (audioPlayCount < (stage.maxAudioPlays || Infinity)) {
                    audioPlayCount++;
                    // Simulate sound play
                    console.log(`Playing audio: ${stage.audioWord}`);
                    group.animate('scaleX', 1.2, { duration: 100, onComplete: () => group.animate('scaleX', 1, { duration: 100 }) });
                }
            });
            canvas.add(group);
        }

        /**
         * RENDERING LOGIC (Drag & Drop)
         */
        function renderDragStage(stage) {
            canvas.clear();
            canvas.backgroundColor = '#FFFFFF';
            dropTargets = [];

            const scale = currentContentScale;
            const centerX = 1280 / 2;
            const barW = 1000 * scale;
            const barH = 110 * scale;
            const barY = 160;

            // Background Area for Draggables
            canvas.add(new fabric.Rect({
                left: centerX, top: barY + barH / 2, width: barW, height: barH,
                fill: '#F1F5F9', rx: 20 * scale, ry: 20 * scale,
                originX: 'center', originY: 'center', selectable: false, evented: false
            }));

            // Main Content Card (The "Bubble")
            const cardY = barY + barH + 40;
            const cardW = 940 * scale;
            const cardH = 480 * scale;

            canvas.add(new fabric.Rect({
                left: centerX, top: cardY + cardH / 2, width: cardW, height: cardH,
                fill: '#FFFFFF', stroke: CONFIG.COLORS.border, strokeWidth: 2 * scale,
                rx: 32 * scale, ry: 32 * scale, originX: 'center', originY: 'center',
                selectable: false, evented: false, shadow: '0 10px 30px rgba(0,0,0,0.05)'
            }));

            // Tokens Layout
            const tokenGap = 160 * scale;
            const startX = centerX - (stage.tokens.length - 1) * tokenGap / 2;
            const contentCenterY = cardY + cardH / 2 - 20 * scale;

            stage.tokens.forEach((token, i) => {
                const x = startX + i * tokenGap;
                const hanjaY = contentCenterY + 40 * scale;
                const pinyinSlotY = contentCenterY - 15 * scale;

                // Hanja Text - Unified Weight and Font
                canvas.add(new fabric.Text(token.char, {
                    left: x, top: hanjaY,
                    fontSize: currentHanjaSize * scale,
                    fontFamily: CONFIG.FONTS.chinese,
                    fontWeight: 700,
                    fill: CONFIG.COLORS.text, originX: 'center', selectable: false, name: 'hanja-text'
                }));

                // Pinyin Slot or Fixed Text
                const slotW = 120 * scale;
                const slotH = 76 * scale;

                if (token.fixed) {
                    canvas.add(new fabric.Text(token.pinyin, {
                        left: x, top: pinyinSlotY,
                        fontSize: currentPinyinSize * scale,
                        fontFamily: CONFIG.FONTS.main,
                        fontWeight: 700,
                        fill: CONFIG.COLORS.accent, originX: 'center', originY: 'center', selectable: false
                    }));
                } else {
                    const slot = new fabric.Rect({
                        left: x, top: pinyinSlotY, width: slotW, height: slotH,
                        fill: 'rgba(79, 70, 229, 0.03)', stroke: CONFIG.COLORS.accent, strokeWidth: 2 * scale,
                        strokeDashArray: [6, 4], rx: 12 * scale, ry: 12 * scale,
                        originX: 'center', originY: 'center', selectable: false, evented: false
                    });
                    canvas.add(slot);
                    dropTargets.push({ x: x, y: pinyinSlotY, width: slotW, height: slotH, visualSlot: slot });
                }
            });

            // Interpretation Subtext
            canvas.add(new fabric.Text(stage.subText, {
                left: centerX, top: cardY + cardH - 70 * scale,
                fontSize: 28 * scale, fontFamily: CONFIG.FONTS.main, fontWeight: 500,
                fill: CONFIG.COLORS.secondary, originX: 'center', selectable: false
            }));

            // Draggable Items logic
            const itemGap = 190 * scale;
            const itemStartX = centerX - (stage.sourceItems.length - 1) * itemGap / 2;
            stage.sourceItems.forEach((item, i) => {
                const itemW = 120 * scale;
                const itemH = 68 * scale;
                const group = new fabric.Group([
                    new fabric.Rect({
                        width: itemW, height: itemH, fill: '#FFFFFF',
                        stroke: CONFIG.COLORS.border, strokeWidth: 1.5 * scale,
                        rx: 12 * scale, ry: 12 * scale,
                        originX: 'center', originY: 'center',
                        shadow: '0 4px 10px rgba(0,0,0,0.08)'
                    }),
                    new fabric.Text(item, {
                        fontSize: currentPinyinSize * 0.85 * scale,
                        fontFamily: CONFIG.FONTS.main, fontWeight: 700,
                        fill: CONFIG.COLORS.text, originX: 'center', originY: 'center'
                    })
                ], {
                    left: itemStartX + i * itemGap, top: barY + barH / 2,
                    originX: 'center', originY: 'center',
                    hasControls: false, hasBorders: false, hoverCursor: 'grab'
                });
                canvas.add(group);
                group.originalPos = { x: group.left, y: group.top };

                group.on('mouseover', () => { group.item(0).set('stroke', CONFIG.COLORS.accent); canvas.renderAll(); });
                group.on('mouseout', () => { group.item(0).set('stroke', CONFIG.COLORS.border); canvas.renderAll(); });
            });

            canvas.renderAll();
        }

        /**
         * INTERACTION LOGIC
         */
        canvas.on('mouse:up', () => {
            const obj = canvas.getActiveObject();
            if (!obj || STAGES[currentStageIndex].inputType !== 'drag') return;

            let snapped = false;
            for (let t of dropTargets) {
                if (Math.abs(obj.left - t.x) < 50 && Math.abs(obj.top - t.y) < 50) {
                    obj.animate({ left: t.x, top: t.y }, {
                        duration: 150, easing: fabric.util.ease.easeOutQuad,
                        onChange: canvas.renderAll.bind(canvas),
                        onComplete: () => {
                            t.visualSlot.set({ strokeWidth: 0, fill: 'transparent' });
                            obj.item(0).set({ strokeWidth: 0, shadow: null, fill: 'transparent' });
                            obj.item(1).set({ fontSize: currentPinyinSize * currentContentScale, fill: CONFIG.COLORS.accent });
                            canvas.renderAll();
                        }
                    });
                    snapped = true;
                    break;
                }
            }

            if (!snapped) {
                obj.animate({ left: obj.originalPos.x, top: obj.originalPos.y }, {
                    duration: 400, easing: fabric.util.ease.easeOutBack,
                    onChange: canvas.renderAll.bind(canvas)
                });
            }
        });

        canvas.on('mouse:down', (o) => {
            if (isMoving || STAGES[currentStageIndex].inputType === 'drag') return;
            const p = canvas.getPointer(o.e);
            const stage = STAGES[currentStageIndex];
            let canDraw = false;

            if (stage.inputType === 'pad') {
                const b = WRITING_PAD_CONFIG;
                canDraw = p.x >= b.x && p.x <= b.x + b.width && p.y >= b.y && p.y <= b.y + b.height;
            } else if (stage.inputType === 'direct' && activeSlotIndex < stage.targets.length) {
                const t = stage.targets[activeSlotIndex];
                const w = t.width * currentExpansionFactor, h = t.height * currentExpansionFactor;
                canDraw = p.x >= t.x - (w - t.width) / 2 && p.x <= t.x + t.width + (w - t.width) / 2 &&
                    p.y >= t.y - (h - t.height) / 2 && p.y <= t.y + t.height + (h - t.height) / 2;
            }

            if (!canDraw && (stage.inputType === 'pad' || stage.inputType === 'direct')) {
                // If clicked outside the valid zone, use transparent color to hide the stroke
                canvas.freeDrawingBrush.color = 'transparent';
            } else if (canDraw) {
                canvas.freeDrawingBrush.color = CONFIG.COLORS.text;
                // Since isDrawingMode is already true, Fabric will accurately catch this first touch.
            }
        });

        canvas.on('path:created', (e) => {
            const stage = STAGES[currentStageIndex];

            // If we are currently resetting or moving, ignore all new paths
            if (isMoving || canvas.freeDrawingBrush.color === 'transparent') {
                canvas.remove(e.path);
                return;
            }

            currentStrokes.push(e.path);
            e.path.selectable = false;

            if (!isMoving) {
                clearTimeout(idleTimer);
                idleTimer = setTimeout(performPlacement, CONFIG.IDLE_TIMEOUT);
            }
        });

        /**
         * HANDWRITING PROCESSING
         */
        function performPlacement() {
            if (currentStrokes.length === 0 || isMoving) return;
            const stage = STAGES[currentStageIndex];
            isMoving = true;
            canvas.isDrawingMode = false;

            if (stage.inputType === 'direct') {
                const target = stage.targets[activeSlotIndex];
                const group = new fabric.Group(currentStrokes, { originX: 'center', originY: 'center', selectable: false });
                currentStrokes.forEach(s => canvas.remove(s));
                canvas.add(group);
                filledSlots[activeSlotIndex] = true;
                activeSlotIndex++;
                animateAndClean(group, target, () => updateActiveZoneVisual());
            } else {
                const available = filledSlots.map((f, i) => f ? -1 : i).filter(v => v !== -1);
                if (available.length === 0) {
                    currentStrokes.forEach(s => canvas.remove(s));
                    currentStrokes = [];
                    isMoving = false;
                    canvas.isDrawingMode = true;
                    return;
                }
                const groups = groupStrokesByCharacter(currentStrokes);
                const toMove = groups.slice(0, available.length);
                const anims = toMove.map((g, i) => {
                    const idx = available[i];
                    filledSlots[idx] = true;
                    const fg = new fabric.Group(g, { originX: 'center', originY: 'center', selectable: false });
                    g.forEach(s => canvas.remove(s));
                    canvas.add(fg);
                    return animateAndClean(fg, stage.targets[idx]);
                });
                Promise.all(anims).then(() => {
                    currentStrokes = [];
                    isMoving = false;
                    canvas.isDrawingMode = true;
                });
            }
        }

        function animateAndClean(obj, target, extraCb) {
            return new Promise(resolve => {
                const br = obj.getBoundingRect();
                const scale = Math.min(target.width * 0.85 / br.width, target.height * 0.85 / br.height, 1.8);
                obj.animate({
                    left: target.x + target.width / 2,
                    top: target.y + target.height / 2,
                    scaleX: scale, scaleY: scale
                }, {
                    duration: CONFIG.ANIMATION_DURATION,
                    easing: fabric.util.ease.easeInOutQuart,
                    onChange: canvas.renderAll.bind(canvas),
                    onComplete: () => {
                        if (extraCb) extraCb();
                        currentStrokes = [];
                        isMoving = false;
                        canvas.isDrawingMode = true;
                        resolve();
                    }
                });
            });
        }

        function groupStrokesByCharacter(strokes) {
            if (strokes.length === 0) return [];
            const data = strokes.map(s => {
                const b = s.getBoundingRect();
                return { o: s, l: b.left, r: b.left + b.width };
            });
            data.sort((a, b) => a.l - b.l);
            const groups = [];
            let cur = [data[0]];
            for (let i = 1; i < data.length; i++) {
                if (data[i].l > Math.max(...cur.map(x => x.r)) + CONFIG.CLUSTER_GAP_THRESHOLD) {
                    groups.push(cur);
                    cur = [data[i]];
                } else {
                    cur.push(data[i]);
                }
            }
            groups.push(cur);
            return groups.map(g => g.map(x => x.o));
        }

        function showHints(stage) {
            if (!stage.targets) return;
            const hints = stage.targets.map((t, i) => {
                const txt = new fabric.Text(stage.hintText[i], {
                    left: t.x + t.width / 2, top: t.y + t.height / 2,
                    fontSize: 64, fontFamily: CONFIG.FONTS.main, fontWeight: 700,
                    fill: CONFIG.COLORS.hint, originX: 'center', originY: 'center',
                    opacity: 0.4, selectable: false, evented: false
                });
                canvas.add(txt);
                return txt;
            });
            hintTimer = setTimeout(() => {
                hints.forEach(h => h.animate('opacity', 0, {
                    duration: 600,
                    onChange: canvas.renderAll.bind(canvas),
                    onComplete: () => canvas.remove(h)
                }));
            }, CONFIG.HINT_DURATION);
        }

        function updateActiveZoneVisual() {
            const stage = STAGES[currentStageIndex];
            if (stage.inputType !== 'direct' || activeSlotIndex >= stage.targets.length) return;
            if (activeZoneRect) canvas.remove(activeZoneRect);
            const t = stage.targets[activeSlotIndex];
            const w = t.width * currentExpansionFactor, h = t.height * currentExpansionFactor;
            activeZoneRect = new fabric.Rect({
                left: t.x - (w - t.width) / 2, top: t.y - (h - t.height) / 2,
                width: w, height: h,
                fill: CONFIG.COLORS.activeZone, stroke: CONFIG.COLORS.activeStroke,
                strokeWidth: 2, strokeDashArray: [8, 4], rx: 20, ry: 20,
                selectable: false, evented: false
            });
            canvas.add(activeZoneRect);
            activeZoneRect.sendToBack();
        }

        /**
         * EVENT LISTENERS
         */
        ui.prev.addEventListener('click', () => loadStage(currentStageIndex - 1));
        ui.next.addEventListener('click', () => loadStage(currentStageIndex + 1));
        ui.reset.addEventListener('click', () => loadStage(currentStageIndex));
        ui.done.addEventListener('click', performPlacement);

        ui.scaleSelect.addEventListener('change', (e) => {
            currentExpansionFactor = parseFloat(e.target.value);
            updateActiveZoneVisual();
        });

        ui.pinyinSlider.addEventListener('input', (e) => {
            currentPinyinSize = parseInt(e.target.value);
            ui.pinyinVal.textContent = currentPinyinSize;
            renderDragStage(STAGES[currentStageIndex]);
        });
        ui.hanjaSlider.addEventListener('input', (e) => {
            currentHanjaSize = parseInt(e.target.value);
            ui.hanjaVal.textContent = currentHanjaSize;
            renderDragStage(STAGES[currentStageIndex]);
        });
        ui.screenSlider.addEventListener('input', (e) => {
            currentContentScale = parseFloat(e.target.value);
            ui.screenVal.textContent = Math.round(currentContentScale * 100);
            renderDragStage(STAGES[currentStageIndex]);
        });

        // Start
        loadStage(0);
    </script>
</body>

</html>